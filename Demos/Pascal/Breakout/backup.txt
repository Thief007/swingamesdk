///
/// GameLogic.pas
///
/// --------------------------------------
///	 This file contains the logic for your
///  game. The Main procedure is called from
///  the game launcher. 
/// --------------------------------------
unit GameLogic;

interface
procedure Main();

implementation
uses
GameResources,
SysUtils,
SGSDK_Core, SGSDK_Font, SGSDK_Audio, SGSDK_Graphics, SGSDK_Input, SGSDK_Physics,
SGSDK_KeyCodes, SGSDK_Shapes;

//The main procedure that controls the game logic.
//
// SIDE EFFECTS:
// - Creates the screen, and displays a message
const
	//screen prop
	screenWidth = 800;
	screenHeight = 600;
	//ball prop.
	ballHeight = 20;
	ballWidth = 20;
	//how high up the screen the player spawns
	playerY = 550;
	//number of bricks per row
	bricksPerRow = 8;
	//number of rows
	brickRows = 5;
	//number of lives
	defaultLives =5;
	// Paddle Prop
	paddleWidth = 120;
	paddleHeight = 20;

	// Brick properties
	brickWidth = 80;
	brickHeight = 20;
	

type
//playerType - for player
playerType = record
	lives: integer;  //lives
	level: integer;  //level
	score: integer;  //score
	playerSprite: Sprite;  //player paddle
	bricksRemaining: integer;  //bricks remain
end;

// brick: used for bricks
brick = record
	brickColor : integer;		// brickcolor: this also controls what score the player will get when this brick is hit
	brickSprite : Sprite;		// brick sprite
	hit : boolean;				// has the brick been hit?
end;



var
	ball: Sprite; //define ball
	player: playerType;
	bricks : array [1..bricksPerRow * brickRows] of brick;
	i: Integer;
	
	
procedure InitialiseBall();
//ball spawn procedure
begin
	ball := CreateSprite(GameImage('ball'));
	// 1/3 of the way across the screen
	ball.X := screenWidth/3-ballWidth/2;
	ball.Y := screenHeight/3-ballHeight/2;
	ball.movement := CreateVector(5+(player.level),7+(player.level));
end;

procedure MovePlayerToDefaultPosition();
begin
	player.playerSprite.X :=(screenWidth/2) - (paddleWidth/2);
	player.playerSprite.Y := playerY;
end;


procedure InitialisePlayer();
//resets the player
begin
	player.lives := defaultLives;
	player.score := 0;
	player.level := 1;

	player.playersprite := CreateSprite(GameImage('paddle'));
	MovePlayerToDefaultPosition;
	player.bricksRemaining := bricksPerRow * brickRows;
end;




function GetBrickCoordinatesFromGridPosition(i : integer) : Point2D;
// x and y co-ords for the bricks that are destroyable
var
	GridX, GridY : integer;
	brickPoint : Point2D;
begin
	// Get the grid coordinates of this brick (ie. row 3 brick 4)
	GridX := ((i-1) mod bricksPerRow) ;
	GridY := ((i-1) div bricksPerRow);

	brickPoint.X := GridX * (brickWidth+10);
	brickPoint.Y := GridY * (brickHeight+10);

	result := brickPoint;
end;




procedure InitialiseBricks();
// Resets the array of bricks
var
	i : integer;
	brickPoint : Point2D;
begin
	for i:= 1 to bricksPerRow*brickRows do
	begin
		// Get the row number / brick color number
		bricks[i].brickColor := ((i-1) div bricksPerRow) + 1;
		// Load the sprite depending on the brick number
		bricks[i].brickSprite := CreateSprite(GameImage('brick' + IntToStr(bricks[i].brickColor)));
		// Create the sprite position
		brickPoint := GetBrickCoordinatesFromGridPosition(i);
		bricks[i].brickSprite.X := (screenWidth/2-(bricksPerRow*90)/2) + brickPoint.X;
		bricks[i].brickSprite.Y := 32 + brickPoint.Y;

		bricks[i].hit := false;
	end;
end;



procedure NextLevel();
// This function is called when there are no more bricks left
begin
	player.level := player.level +1;
	player.bricksRemaining := bricksPerRow*brickRows;
	// Reset the number of bricks remaining.
	
	MovePlayerToDefaultPosition();
	InitialiseBricks();
	InitialiseBall();
end;



procedure LoseALife();
begin
// Take off one life
	player.lives -=1;
	if player.lives <0 then
	begin
		// The player is dead.
		// Remove the ball from the screen and prevent it from moving.
		ball.x := -ballWidth;
		ball.y := -ballHeight;
		ball.Movement := CreateVector(0,0);

		
		// Show the Game Over screen, asking the user if they want to continue.
		repeat
			ProcessEvents();
			ClearScreen(ColorBlack);
			// Draw the Game Over bitmap at point (0,0).
			//DrawBitmapOnScreen(GameImage('gameover'), CreatePoint(0,0));
			DrawText('Game Over',ColorWhite,GameFont('UnrealL'),180,50);
			DrawText('Press Y                New Game',ColorWhite,GameFont('28day'),160,200);
			DrawText('Press Esc or N          To Quit',ColorWhite,GameFont('28day'),160,300);
			RefreshScreen(25);
		// Wait until Y, N or Escape is pressed.
		until IsKeyPressed(VK_Y) or IsKeyPressed(VK_Escape) or IsKeyPressed(VK_N) or WindowCloseRequested();
		
		// Did they press Y?
		if IsKeyPressed(VK_Y) then
			begin
				// Reset the game
				InitialisePlayer();
				InitialiseBricks();
				InitialiseBall();
			end;
	end	
	else
	begin
		// The player still has lives remaining, so just reset the ball position.
		InitialiseBall();
	end;
end;


procedure Menu();
var
	selection: integer;
begin
		DrawText('1. Play Game', ColorWhite, GameFont('ArialMed'), 100, 50);
		DrawText('2. Options', ColorWhite, GameFont('ArialMed'), 100, 100);
		DrawText('3. High Score Table', ColorWhite, GameFont('ArialMed'),100,150);
		DrawText('4. Quit', ColorWhite,GameFont('ArialMed'), 100, 200);
		ReadLn(selection);
		case selection of
			1:  
			2: 
			3: 
			4: 
		end;
end;


Procedure ScreenBallRestriction();
//bounce ball of edge of screen
// x values (uses width)
//y values (uses height)
begin
if ball.X < 0 then
	begin
		ball.X:= 0;
		ball.Movement.X:= -ball.Movement.X;
	end;
	if ball.X > screenWidth-ballWidth then
	begin
		ball.X := screenWidth-ballWidth;
		ball.Movement.X := -ball.Movement.X;
	end;

	if ball.Y < 0 then
	begin
		ball.Y := 0;
		ball.Movement.Y := -ball.Movement.Y;
	end;
	
	if ball.y > screenHeight-ballHeight then
	begin
		LoseALife();
	end;
end;


procedure MovementControls();
//check if player moves
begin
	if IsKeyPressed(VK_LEFT) then
		player.playerSprite.Movement.X := -9
	else if IsKeyPressed(VK_RIGHT) then
		player.playerSprite.Movement.X := 9
	else
		player.playerSprite.Movement.X := 0;
end;

procedure PlayerRestrictions();
begin
if player.playerSprite.X < 0 then
	begin
		player.playerSPrite.X := 0;
		player.playerSPrite.Movement.X :=0;
	end
	
	else if player.playerSprite.X > (screenWidth-paddleWidth) then
	begin
		player.playerSprite.X := screenWidth-paddleWidth;
		player.playerSprite.Movement.X :=0;
	end;
end;

procedure BatPaddleHit();
begin
if HaveSpritesCollided(ball, player.playerSprite) then
	begin
		ball.Movement.Y := -ball.Movement.Y;
		ball.Movement.X := ball.Movement.X + (player.playerSprite.Movement.X/2);
	end;
end;

procedure BallBrickHit();
//check if ball hit brick
begin
	for i := 1 to bricksPerRow * brickRows do
	begin
		if HaveSpritesCollided(ball, bricks[i].brickSprite) and (bricks[i].hit = false) then
		begin
			//  Hit a brick!
			bricks[i].hit := true;
			// Take from the number of bricks remaining
			player.bricksRemaining := player.bricksRemaining -1;
			if player.bricksremaining = 0 then
			begin
				NextLevel();
			end;
			
			// Bounce the ball off the brick
			ball.Movement.Y := -ball.Movement.Y;
			// Increase the player’s score
			player.score += (brickRows-bricks[i].brickColor+1)*50;
		end;
	end;
end;

procedure Hud();
begin
	DrawText('Level: ' + IntToStr(player.level) + '      Lives: ' + IntToStr(player.lives) + '      Score: ' + IntToStr(player.score) + '      Remaining: ' + IntToStr(player.bricksRemaining), ColorWhite, GameFont('ArialSmall'), 8, 8);
end;


procedure Main();
var
i: integer;
begin
	OpenGraphicsWindow('Breakout by PyroZeroX', screenWidth, screenHeight);
	LoadResources();
	InitialiseBall();  
	InitialisePlayer();
	InitialiseBricks();

	PlayMusic(GameMusic('bgmusic'));
	
repeat
	ProcessEvents();
	ScreenBallRestriction();
	
	//end game when player loses last life
	if player.lives <0 then break;
	
	MovementControls();
	
	PlayerRestrictions();
	BatPaddleHit();
	BallBrickHit();
	
	//Draw graphics
	ClearScreen(ColorBlack);
	
	//Draw Background
	DrawBitmap(GameImage('background'), 0, 0);
	//Draw Ball
	DrawSprite(ball);
	UpdateSprite(ball);

	// Draw the player
	DrawSprite(player.playerSprite);
	UpdateSprite(player.playerSprite);

	// Draw the bricks
	for i := 1 to bricksPerRow*brickRows do
	begin
		if bricks[i].hit = false then
			begin
				DrawSprite(bricks[i].brickSprite);
				UpdateSprite(bricks[i].brickSprite);
			end;
	end;
	
	Hud();
	//refresh rate
	RefreshScreen(60);
	until WindowCloseRequested();

	FreeResources();
end;

end.
